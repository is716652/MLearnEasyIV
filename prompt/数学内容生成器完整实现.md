

## 数学内容生成器完整实现

### 1. 首先更新内容生成器结构

```python
# app/ml_content/math_content.py
import numpy as np
import matplotlib.pyplot as plt
import sympy as sp
from io import BytesIO
import base64
import math
from typing import Dict, Any, List
import logging

logger = logging.getLogger(__name__)

class MathContentGenerator:
    def __init__(self):
        self.x, self.y, self.z = sp.symbols('x y z')
    
    def generate_math_content(self, subcategory: str, title: str) -> Dict[str, Any]:
        """根据子分类和标题生成数学内容"""
        content_methods = {
            # 基础概念
            "常量": self._generate_constant_content,
            "变量": self._generate_variable_content,
            "函数": self._generate_function_content,
            
            # 代数运算
            "幂": self._generate_power_content,
            "平方根": self._generate_sqrt_content,
            "多项式函数": self._generate_polynomial_content,
            
            # 特殊函数
            "三角函数": self._generate_trigonometric_content,
            "总和": self._generate_sum_content,
            "乘积": self._generate_product_content,
            "随机数": self._generate_random_content,
            "绝对值": self._generate_absolute_content,
            
            # 线性代数
            "标量与向量": self._generate_scalar_vector_content,
            "矩阵与张量": self._generate_matrix_tensor_content,
            "行列向量": self._generate_row_column_vector_content,
            "向量的转置": self._generate_vector_transpose_content,
            "向量的加减": self._generate_vector_operations_content,
            "向量的点积和范数": self._generate_dot_norm_content,
            "矩阵的积": self._generate_matrix_multiplication_content,
            
            # 微积分与应用
            "导数": self._generate_derivative_content,
            "偏导数": self._generate_partial_derivative_content,
            "损失函数": self._generate_loss_function_content,
            "激活函数": self._generate_activation_function_content,
        }
        
        for key, method in content_methods.items():
            if key in subcategory or key in title:
                return method()
        
        # 默认内容
        return self._generate_default_content()

    def _create_chart_base64(self, fig) -> str:
        """将matplotlib图表转换为base64字符串"""
        buffer = BytesIO()
        fig.savefig(buffer, format='png', dpi=100, bbox_inches='tight')
        buffer.seek(0)
        img_str = base64.b64encode(buffer.read()).decode()
        plt.close(fig)
        return img_str

    # 基础概念内容生成方法
    def _generate_constant_content(self) -> Dict[str, Any]:
        """生成常量相关内容"""
        content_body = """
## 常量（Constants）

### 生活化类比
想象一下数学中的π（圆周率）≈ 3.14159，它是一个固定不变的值，就像你的生日一样永远不会改变。

### 理论讲解
常量是程序中固定不变的值，一旦定义就不能修改。在数学和编程中，常量用于表示不会改变的数值。

### 数学表示
- 数学常量：$\\pi$, $e$, $\\phi$ (黄金比例)
- 物理常量：$c$ (光速), $G$ (万有引力常数)
        """
        
        python_code = """
# Python中的常量表示
PI = 3.141592653589793
E = 2.718281828459045
SPEED_OF_LIGHT = 299792458  # 光速，单位m/s

print(f"圆周率π: {PI}")
print(f"自然常数e: {E}")
print(f"光速c: {SPEED_OF_LIGHT} m/s")

# 在Python中，通常用全大写字母表示常量（约定俗成）
GRAVITY = 9.8  # 重力加速度
print(f"重力加速度g: {GRAVITY} m/s²")

# 注意：Python没有真正的常量，这只是命名约定
# 实际开发中应该避免修改这些"常量"值
        """
        
        return {
            "content_body": content_body,
            "python_code": python_code,
            "formulas": {
                "pi": "\\pi \\approx 3.141592653589793",
                "e": "e \\approx 2.718281828459045"
            },
            "charts_data": {}
        }

    def _generate_variable_content(self) -> Dict[str, Any]:
        """生成变量相关内容"""
        content_body = """
## 变量（Variables）

### 生活化类比
变量就像数学中的未知数x，或者编程中的存储容器。比如：年龄 = 25，这里的"年龄"就是一个变量。

### 理论讲解
变量是存储数据的容器，其值可以在程序执行过程中改变。每个变量都有名称和数据类型。

### 变量类型
- 整型 (int): 整数，如 1, 2, -5
- 浮点型 (float): 小数，如 3.14, -0.5
- 字符串 (str): 文本，如 "hello", "机器学习"
- 布尔型 (bool): True 或 False
        """
        
        python_code = """
# 变量定义和赋值
age = 25  # 整型变量
name = "张三"  # 字符串变量
height = 1.75  # 浮点型变量
is_student = True  # 布尔型变量

print(f"姓名: {name}")
print(f"年龄: {age}岁")
print(f"身高: {height}米")
print(f"是否是学生: {is_student}")

# 变量重新赋值
age = 26  # 变量值可以改变
print(f"明年年龄: {age}岁")

# 多重赋值
x, y, z = 1, 2, 3
print(f"x={x}, y={y}, z={z}")

# 查看变量类型
print(f"age的类型: {type(age)}")
print(f"name的类型: {type(name)}")
print(f"height的类型: {type(height)}")
        """
        
        return {
            "content_body": content_body,
            "python_code": python_code,
            "formulas": {
                "variable_definition": "x = 5,\\quad y = 3.14,\\quad z = \\text{'hello'}"
            },
            "charts_data": {}
        }

    def _generate_function_content(self) -> Dict[str, Any]:
        """生成函数相关内容"""
        content_body = """
## 函数（Functions）

### 生活化类比
函数就像一台自动售货机：你投入参数（钱和选择），它返回结果（饮料）。比如：f(x) = x²，输入2得到4。

### 理论讲解
函数是一段可重复使用的代码块，接受输入（参数），进行处理，然后返回输出（返回值）。

### 函数组成
- 函数定义: def 函数名(参数):
- 函数调用: 函数名(实际参数)
- 返回值: return 语句
        """
        
        python_code = """
# 函数定义和调用
def square(x):
    \"\"\"计算平方\"\"\"
    return x ** 2

def add(a, b):
    \"\"\"两数相加\"\"\"
    return a + b

def greet(name, greeting="你好"):
    \"\"\"打招呼函数，有默认参数\"\"\"
    return f"{greeting}, {name}!"

# 函数调用
result1 = square(5)
result2 = add(3, 7)
result3 = greet("李四")
result4 = greet("王五", "Hello")

print(f"5的平方: {result1}")
print(f"3 + 7 = {result2}")
print(result3)
print(result4)

# Python内置函数示例
numbers = [1, 2, 3, 4, 5]
print(f"最大值: {max(numbers)}")
print(f"最小值: {min(numbers)}")
print(f"求和: {sum(numbers)}")
print(f"长度: {len(numbers)}")
print(f"绝对值: {abs(-10)}")
        """
        
        return {
            "content_body": content_body,
            "python_code": python_code,
            "formulas": {
                "function_definition": "f(x) = x^2",
                "function_call": "f(2) = 4"
            },
            "charts_data": {}
        }

    # 代数运算内容生成方法
    def _generate_power_content(self) -> Dict[str, Any]:
        """生成幂运算相关内容"""
        content_body = """
## 幂运算（Power）

### 生活化类比
幂运算就像复利计算：本金100元，年利率10%，3年后就是100 × (1.10)³ = 133.1元。

### 理论讲解
幂运算表示一个数自乘若干次，格式为：底数ᵉˣᵖᵒⁿᵉⁿᵗ，如 2³ = 2 × 2 × 2 = 8

### 数学公式
$a^n = a \\times a \\times \\cdots \\times a$ (n次)
        """
        
        python_code = """
import math

# 使用 ** 运算符
result1 = 2 ** 3  # 2的3次方
result2 = 5 ** 2  # 5的平方
result3 = 10 ** 0.5  # 10的平方根

print(f"2的3次方: {result1}")
print(f"5的平方: {result2}")
print(f"10的平方根: {result3}")

# 使用 math.pow() 函数
result4 = math.pow(2, 3)
result5 = math.pow(5, 2)
result6 = math.pow(10, 0.5)

print(f"math.pow(2, 3): {result4}")
print(f"math.pow(5, 2): {result5}")
print(f"math.pow(10, 0.5): {result6}")

# 负指数和分数指数
result7 = 2 ** -2  # 2的-2次方 = 1/4
result8 = 8 ** (1/3)  # 8的立方根 = 2

print(f"2的-2次方: {result7}")
print(f"8的立方根: {result8}")

# 比较大数计算
large_number = 10 ** 100  # 10的100次方（Googol）
print(f"10的100次方有 {len(str(large_number))} 位数")
        """
        
        # 创建幂函数图像
        fig, ax = plt.subplots(figsize=(10, 6))
        x = np.linspace(0, 5, 100)
        y1 = x ** 2  # 平方
        y2 = x ** 3  # 立方
        y3 = 2 ** x  # 指数函数
        
        ax.plot(x, y1, label='$y = x^2$', linewidth=2)
        ax.plot(x, y2, label='$y = x^3$', linewidth=2)
        ax.plot(x, y3, label='$y = 2^x$', linewidth=2)
        
        ax.set_xlabel('x')
        ax.set_ylabel('y')
        ax.set_title('幂函数图像')
        ax.legend()
        ax.grid(True)
        
        chart_data = self._create_chart_base64(fig)
        
        return {
            "content_body": content_body,
            "python_code": python_code,
            "formulas": {
                "power_definition": "a^n = \\underbrace{a \\times a \\times \\cdots \\times a}_{n\\text{次}}",
                "negative_exponent": "a^{-n} = \\frac{1}{a^n}",
                "fraction_exponent": "a^{\\frac{m}{n}} = \\sqrt[n]{a^m}"
            },
            "charts_data": {"power_function": chart_data}
        }

    def _generate_sqrt_content(self) -> Dict[str, Any]:
        """生成平方根相关内容"""
        content_body = """
## 平方根（Square Root）

### 生活化类比
平方根就像"反向平方"：如果知道正方形面积是16，边长就是√16 = 4。

### 理论讲解
平方根是一个数的1/2次方，满足：如果 y² = x，那么 y 是 x 的平方根。

### 数学公式
$\\sqrt{x} = x^{\\frac{1}{2}}$
        """
        
        python_code = """
import math
import numpy as np

# 使用 math.sqrt()
result1 = math.sqrt(16)
result2 = math.sqrt(2)  # 无理数
result3 = math.sqrt(0.25)

print(f"√16 = {result1}")
print(f"√2 ≈ {result2}")
print(f"√0.25 = {result3}")

# 使用指数运算
result4 = 16 ** 0.5
result5 = 9 ** (1/2)

print(f"16**0.5 = {result4}")
print(f"9**(1/2) = {result5}")

# 使用 numpy.sqrt() 处理数组
numbers = np.array([4, 9, 16, 25])
sqrt_numbers = np.sqrt(numbers)
print(f"数组平方根: {sqrt_numbers}")

# 复数平方根
complex_result = np.sqrt(-4 + 0j)  # 2j
print(f"√(-4) = {complex_result}")

# 验证平方根
x = 25
sqrt_x = math.sqrt(x)
print(f"验证: ({sqrt_x})² = {sqrt_x ** 2}")
        """
        
        # 创建平方根函数图像
        fig, ax = plt.subplots(figsize=(10, 6))
        x = np.linspace(0, 10, 100)
        y = np.sqrt(x)
        
        ax.plot(x, y, label='$y = \\sqrt{x}$', linewidth=2, color='blue')
        ax.fill_between(x, y, alpha=0.2, color='blue')
        
        # 标记几个特殊点
        special_points = [0, 1, 4, 9]
        for point in special_points:
            ax.plot(point, np.sqrt(point), 'ro')
            ax.annotate(f'({point}, {np.sqrt(point):.1f})', 
                       (point, np.sqrt(point)), 
                       xytext=(5, 5), textcoords='offset points')
        
        ax.set_xlabel('x')
        ax.set_ylabel('y')
        ax.set_title('平方根函数图像')
        ax.legend()
        ax.grid(True)
        
        chart_data = self._create_chart_base64(fig)
        
        return {
            "content_body": content_body,
            "python_code": python_code,
            "formulas": {
                "sqrt_definition": "\\sqrt{x} = y \\quad \\text{其中} \\quad y^2 = x",
                "sqrt_properties": "\\sqrt{a \\times b} = \\sqrt{a} \\times \\sqrt{b}"
            },
            "charts_data": {"sqrt_function": chart_data}
        }

    # 由于篇幅限制，这里只展示部分实现
    # 其他函数按照类似模式实现...

    def _generate_polynomial_content(self) -> Dict[str, Any]:
        """生成多项式函数内容"""
        # 实现多项式相关内容
        pass

    def _generate_trigonometric_content(self) -> Dict[str, Any]:
        """生成三角函数内容"""
        # 实现三角函数相关内容
        pass

    # 继续实现其他数学内容...

    def _generate_vector_operations_content(self) -> Dict[str, Any]:
        """生成向量加减运算内容"""
        content_body = """
## 向量的加减运算

### 生活化类比
向量加减就像导航：从家到学校是向量A，从学校到超市是向量B，那么从家到超市就是A + B。

### 理论讲解
向量加减遵循分量相加/相减的原则，只有相同维度的向量才能进行加减运算。

### 数学公式
$\\vec{a} + \\vec{b} = \\begin{bmatrix} a_1 + b_1 \\\\ a_2 + b_2 \\\\ \\vdots \\\\ a_n + b_n \\end{bmatrix}$
        """
        
        python_code = """
import numpy as np

# 向量创建
vector_a = np.array([1, 2, 3])
vector_b = np.array([4, 5, 6])

print(f"向量A: {vector_a}")
print(f"向量B: {vector_b}")

# 向量加法
vector_sum = vector_a + vector_b
print(f"A + B = {vector_sum}")

# 向量减法
vector_diff = vector_a - vector_b
print(f"A - B = {vector_diff}")

# 标量与向量加法（广播机制）
scalar = 2
vector_scalar_add = vector_a + scalar
print(f"A + {scalar} = {vector_scalar_add}")

# 不同维度向量不能相加
try:
    vector_c = np.array([1, 2])
    invalid_sum = vector_a + vector_c
except ValueError as e:
    print(f"错误: {e}")

# 可视化向量加减
print("\\n向量加减几何意义:")
print("向量加法: 平行四边形法则")
print("向量减法: 指向被减向量的三角形法则")

# 实际应用：位移计算
displacement1 = np.array([3, 4])  # 向东3米，向北4米
displacement2 = np.array([1, -2])  # 向东1米，向南2米
total_displacement = displacement1 + displacement2
print(f"总位移: {total_displacement}")
print(f"总距离: {np.linalg.norm(total_displacement):.2f}米")
        """
        
        # 创建向量加减可视化
        fig, ax = plt.subplots(figsize=(10, 8))
        
        # 向量A和B
        a = np.array([2, 3])
        b = np.array([3, 1])
        
        # 绘制向量
        ax.quiver(0, 0, a[0], a[1], angles='xy', scale_units='xy', scale=1, color='r', label='向量A')
        ax.quiver(0, 0, b[0], b[1], angles='xy', scale_units='xy', scale=1, color='b', label='向量B')
        
        # 绘制向量和
        sum_vec = a + b
        ax.quiver(0, 0, sum_vec[0], sum_vec[1], angles='xy', scale_units='xy', scale=1, color='g', label='A + B')
        
        # 绘制平行四边形
        ax.quiver(a[0], a[1], b[0], b[1], angles='xy', scale_units='xy', scale=1, color='b', linestyle='--')
        ax.quiver(b[0], b[1], a[0], a[1], angles='xy', scale_units='xy', scale=1, color='r', linestyle='--')
        
        ax.set_xlim(-1, 6)
        ax.set_ylim(-1, 5)
        ax.set_xlabel('X轴')
        ax.set_ylabel('Y轴')
        ax.set_title('向量加减法几何意义')
        ax.legend()
        ax.grid(True)
        ax.set_aspect('equal')
        
        chart_data = self._create_chart_base64(fig)
        
        return {
            "content_body": content_body,
            "python_code": python_code,
            "formulas": {
                "vector_addition": "\\vec{a} + \\vec{b} = \\begin{bmatrix} a_1 + b_1 \\\\ a_2 + b_2 \\end{bmatrix}",
                "vector_subtraction": "\\vec{a} - \\vec{b} = \\begin{bmatrix} a_1 - b_1 \\\\ a_2 - b_2 \\end{bmatrix}"
            },
            "charts_data": {"vector_operations": chart_data}
        }

    def _generate_activation_function_content(self) -> Dict[str, Any]:
        """生成激活函数内容"""
        content_body = """
## 激活函数（Activation Functions）

### 生活化类比
激活函数就像神经元的"开关"：输入信号达到一定阈值才激活，类似你听到重要消息时的反应。

### 理论讲解
激活函数为神经网络引入非线性，使网络能够学习复杂模式。常见激活函数有Sigmoid、ReLU、Tanh等。

### 数学公式
- Sigmoid: $\\sigma(x) = \\frac{1}{1 + e^{-x}}$
- ReLU: $\\text{ReLU}(x) = \\max(0, x)$  
- Tanh: $\\tanh(x) = \\frac{e^x - e^{-x}}{e^x + e^{-x}}$
        """
        
        python_code = """
import numpy as np
import matplotlib.pyplot as plt

def sigmoid(x):
    \"\"\"Sigmoid激活函数\"\"\"
    return 1 / (1 + np.exp(-x))

def relu(x):
    \"\"\"ReLU激活函数\"\"\"
    return np.maximum(0, x)

def tanh(x):
    \"\"\"Tanh激活函数\"\"\"
    return np.tanh(x)

# 测试激活函数
x = np.array([-2, -1, 0, 1, 2])
print(f"输入: {x}")
print(f"Sigmoid: {sigmoid(x)}")
print(f"ReLU: {relu(x)}") 
print(f"Tanh: {tanh(x)}")

# 在神经网络中的应用示例
def simple_neuron(inputs, weights, bias, activation):
    \"\"\"简单神经元计算\"\"\"
    linear_output = np.dot(inputs, weights) + bias
    return activation(linear_output)

# 示例：AND逻辑门
inputs = np.array([[0, 0], [0, 1], [1, 0], [1, 1]])
weights = np.array([1, 1])
bias = -1.5

and_outputs = [simple_neuron(inp, weights, bias, sigmoid) for inp in inputs]
print(f"\\nAND逻辑门输出(Sigmoid): {and_outputs}")

# 使用ReLU的线性回归示例
def relu_regression(x, w, b):
    return relu(w * x + b)

x_data = np.linspace(-2, 2, 100)
y_data = relu_regression(x_data, 1, 0.5)
        """
        
        # 创建激活函数图像
        fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(15, 6))
        
        x = np.linspace(-5, 5, 100)
        
        # 左侧图：三个激活函数
        ax1.plot(x, sigmoid(x), label='Sigmoid', linewidth=2)
        ax1.plot(x, relu(x), label='ReLU', linewidth=2)
        ax1.plot(x, tanh(x), label='Tanh', linewidth=2)
        
        ax1.set_xlabel('x')
        ax1.set_ylabel('y')
        ax1.set_title('常用激活函数')
        ax1.legend()
        ax1.grid(True)
        
        # 右侧图：Sigmoid导数
        sigmoid_derivative = sigmoid(x) * (1 - sigmoid(x))
        ax2.plot(x, sigmoid_derivative, label='Sigmoid导数', linewidth=2, color='red')
        ax2.plot(x, sigmoid(x), label='Sigmoid', linewidth=2, color='blue')
        
        ax2.set_xlabel('x')
        ax2.set_ylabel('y')
        ax2.set_title('Sigmoid函数及其导数')
        ax2.legend()
        ax2.grid(True)
        
        chart_data = self._create_chart_base64(fig)
        
        return {
            "content_body": content_body,
            "python_code": python_code,
            "formulas": {
                "sigmoid": "\\sigma(x) = \\frac{1}{1 + e^{-x}}",
                "relu": "\\text{ReLU}(x) = \\max(0, x)",
                "tanh": "\\tanh(x) = \\frac{e^x - e^{-x}}{e^x + e^{-x}}",
                "sigmoid_derivative": "\\sigma'(x) = \\sigma(x)(1 - \\sigma(x))"
            },
            "charts_data": {"activation_functions": chart_data}
        }

    def _generate_default_content(self) -> Dict[str, Any]:
        """默认内容生成"""
        return {
            "content_body": "该数学知识点内容正在开发中...",
            "python_code": "# 代码示例待添加",
            "formulas": {},
            "charts_data": {}
        }
```

### 2. 更新主内容生成器

```python
# app/ml_content/content_generator.py
from .math_content import MathContentGenerator
from .ml_content import MLContentGenerator
from typing import Dict, Any

class ContentGenerator:
    def __init__(self):
        self.math_generator = MathContentGenerator()
        self.ml_generator = MLContentGenerator()
    
    def generate_content(self, module: str, subcategory: str, title: str) -> Dict[str, Any]:
        """根据模块生成内容"""
        if module == "math":
            return self.math_generator.generate_math_content(subcategory, title)
        elif module == "ml":
            return self.ml_generator.generate_ml_content(subcategory, title)
        elif module == "dl":
            return self._generate_dl_content(subcategory, title)
        else:
            return self._generate_default_content()
    
    def _generate_dl_content(self, subcategory: str, title: str) -> Dict[str, Any]:
        """生成深度学习内容"""
        return {
            "content_body": "深度学习内容正在开发中...",
            "python_code": "# 深度学习代码示例",
            "formulas": {},
            "charts_data": {}
        }
    
    def _generate_default_content(self) -> Dict[str, Any]:
        """默认内容"""
        return {
            "content_body": "内容正在开发中...",
            "python_code": "# 代码示例待添加",
            "formulas": {},
            "charts_data": {}
        }
```

### 3. 数据库初始化脚本

```python
# app/init_database.py
from app.database import SessionLocal, engine
from app import models
from app.ml_content.content_generator import ContentGenerator
import logging

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

def init_math_content():
    """初始化数学内容"""
    db = SessionLocal()
    generator = ContentGenerator()
    
    math_topics = [
        # 基础概念
        {"module": "math", "subcategory": "基础概念", "title": "常量与变量"},
        {"module": "math", "subcategory": "基础概念", "title": "函数定义与调用"},
        
        # 代数运算
        {"module": "math", "subcategory": "代数运算", "title": "幂运算"},
        {"module": "math", "subcategory": "代数运算", "title": "平方根计算"},
        {"module": "math", "subcategory": "代数运算", "title": "多项式函数"},
        
        # 特殊函数
        {"module": "math", "subcategory": "特殊函数", "title": "三角函数"},
        {"module": "math", "subcategory": "特殊函数", "title": "求和运算"},
        {"module": "math", "subcategory": "特殊函数", "title": "乘积运算"},
        {"module": "math", "subcategory": "特殊函数", "title": "随机数生成"},
        {"module": "math", "subcategory": "特殊函数", "title": "绝对值函数"},
        
        # 线性代数
        {"module": "math", "subcategory": "线性代数", "title": "标量与向量"},
        {"module": "math", "subcategory": "线性代数", "title": "矩阵与张量"},
        {"module": "math", "subcategory": "线性代数", "title": "行列向量转换"},
        {"module": "math", "subcategory": "线性代数", "title": "向量的转置"},
        {"module": "math", "subcategory": "线性代数", "title": "向量的加减运算"},
        {"module": "math", "subcategory": "线性代数", "title": "向量的点积和范数"},
        {"module": "math", "subcategory": "线性代数", "title": "矩阵的乘法运算"},
        
        # 微积分与应用
        {"module": "math", "subcategory": "微积分", "title": "导数概念与计算"},
        {"module": "math", "subcategory": "微积分", "title": "偏导数计算"},
        {"module": "math", "subcategory": "应用", "title": "损失函数(MSE/MAE)"},
        {"module": "math", "subcategory": "应用", "title": "激活函数(Sigmoid/ReLU/Tanh)"},
    ]
    
    for topic in math_topics:
        # 检查是否已存在
        existing = db.query(models.Content).filter(
            models.Content.title == topic["title"]
        ).first()
        
        if not existing:
            logger.info(f"生成内容: {topic['title']}")
            generated = generator.generate_content(
                topic["module"], topic["subcategory"], topic["title"]
            )
            
            content = models.Content(
                module=topic["module"],
                subcategory=topic["subcategory"],
                title=topic["title"],
                content_body=generated["content_body"],
                python_code=generated["python_code"],
                formulas=generated["formulas"],
                charts_data=generated["charts_data"],
                tags=[topic["subcategory"], topic["title"].split("(")[0]]
            )
            
            db.add(content)
    
    db.commit()
    db.close()
    logger.info("数学内容初始化完成")

if __name__ == "__main__":
    # 创建数据库表
    models.Base.metadata.create_all(bind=engine)
    
    # 初始化内容
    init_math_content()
```

### 4. 使用说明

1. **安装依赖**：
```bash
pip install numpy matplotlib sympy scikit-learn
```

2. **初始化数据库**：
```bash
python -m app.init_database
```

3. **启动服务**：
```bash
uvicorn app.main:app --reload
```

4. **测试API**：
访问 `http://localhost:8000/docs` 查看API文档，测试以下端点：
- `GET /api/v1/content/` - 获取所有内容
- `GET /api/v1/content/?module=math` - 获取数学内容
- `GET /api/v1/content/?subcategory=线性代数` - 获取线性代数内容
- `POST /api/v1/content/generate/` - 生成新内容

这个实现提供了完整的数学知识模块，每个知识点都包含：
1. 生活化类比解释
2. 理论讲解和数学公式
3. 可运行的Python代码
4. 可视化图表
5. LaTeX公式支持

前端可以通过API获取这些内容，并使用MathJax渲染公式，显示图表和代码。